<!DOCTYPE html>
<html>
<head>
	<title>PV GazeTrackr</title>
	<link rel="stylesheet" type="text/css" href="./styles/main.css">
</head>

<body>
<div id="content">
		<!-- canvas -->
		<!-- experiment interface -->
		<canvas id="fullscreen" style="display: none;"></canvas>
		<!-- fullscreen overlay -->
		<canvas id="fsoverlay" style="display: none;"></canvas>
		<!-- video streaming -->
		<canvas id="imgCanvas" width="640" height="360" style="display: none;"></canvas>
		<!-- facial landmark tracking -->
		<canvas id="overlay" width="640" height="360" style="display: none;"></canvas>
		<!-- facial landmark tracker insturction -->
		<canvas id="msgoverlay" width="640" height="360" style="display: none;"></canvas>
		<!-- optical flow visualization -->
		<canvas id="opticalflow" position="absolute" width="640" height="360" style="display: none;"></canvas>
		<!-- buttons -->
		<button id="copylinkButton" style="display: none;">Copy Link to Clipboard</button>
		<button id="fullscreenButton" onclick="enterFullScreen();" style="display: none;">Enter Full Screen</button>
		<button id="reTrack" onclick="restartTracking();" disabled="disabled" style="display: none;">Restart Tracking</button>
		<button id="start" onclick="startTask();" disabled="disabled" style="display: none;">Start Experiment</button>
		<button id="replayButton" onclick="visReset();" style="display: none;">Visualize Results</button>
		<button id="downloadButton" onclick="download();" style="display: none;">Download Data</button>
		<!-- <button id="downloadButtonRaw" onclick="downloadraw();" style="display: none;">Download Raw Data</button> -->
		<button id="quitFullScreenButton" onclick="quitfullscreen();" disabled="disabled" style="display: none;">Quit Full Screen</button>
		<button id="closeWinButton" onclick="closetab();" disabled="disabled" style="display: none;">Close Tab</button>
		<!-- instruction message -->
		<p id="instrmsgP" style="display: none;"></p>
		<p id="statusmsgP" style="display: none;"></p>
		<p id="vismsgP" style="display: none;"></p>
		<!-- upload progress -->
		<div id="slider" style="display: none;">
		    <div id="sliderbar">
		    </div>
		    <div id="progress">
		    </div>
		</div>
		
		<p id="memmark" style="display: none;"></p>
		<!-- <input type="radio" name="mem_ans" value="true">Yes<br>
		<input type="radio" name="mem_ans" value="false"> No<br> -->
		<p id="memscore" style="display: none;"></p>
		<p id="bestmemscore" style="display: none;"></p>
		<button id="startmemtestButton" onclick="startMemTest();" style="display: none;">Start Memory Game</button>
		<button id="memtestButton" onclick="submitMemTest();" style="display: none;">Finished!</button>
		<button id="finishmemtestButton" onclick="finishMemTest();" style="display: none;">OK, Next</button>
	
</div>

<!-- js library -->
<script src="./js/jquery-1.11.0.min.js"></script>
<script src="./js/json.js"></script>
<script src="./js/jsfeat.js"></script>
<!-- test webbrowser -->
<script type="text/javascript" src="./js/bowser.min.js"></script>
<!-- copy address to clipboard -->
<script type="text/javascript" src="./js/jquery.zclip.js"></script>
<!-- clm facial landmark tracker -->
<script src="./clmtrackr/js/utils.js"></script>
<script src="./clmtrackr/js/numeric-1.2.6.min.js"></script>
<script src="./clmtrackr/js/mosse.js"></script>
<script src="./clmtrackr/js/left_eye_filter.js"></script>
<script src="./clmtrackr/js/right_eye_filter.js"></script>
<script src="./clmtrackr/js/nose_filter.js"></script>
<script src="./clmtrackr/models/model_pca_20_svm.js"></script>
<script src="./clmtrackr/js/clmpm.js"></script>
<script src="./clmtrackr/js/ccv.js"></script>
<script src="./clmtrackr/js/cascade.js"></script>
<script src="./clmtrackr/js/svmfilter_webgl.js"></script>
<script src="./clmtrackr/js/svmfilter_fft.js"></script>
<script src="./clmtrackr/js/mossefilter.js"></script>
<script src="./clmtrackr/js/Stats.js"></script>
<!-- setting and parameters -->
<script src="./config/imgname.js"></script>
<script src="./config/qtimgname.js"></script>
<script src="./config/testimgname.js"></script>
<script src="./config/parameter.js"></script>
<!-- utility functions -->
<script src="./js/utils.js"></script>
<!-- experiment setting -->
<script src="./config/exprmtconfig.js"></script>
<!-- feature extraction -->
<script src="./js/extractHistFeature.js"></script>
<!-- optical flow for stabilization -->
<script src="./js/OpticalFlow.js"></script>
<!-- regression model -->
<script src="./js/RidgeRegression.js"></script>
<script src="./js/MLModel.js"></script>
<!-- download data -->
<script src="./js/swfobject.js"></script>
<script src="./js/downloadify.js"></script>
<script src="./js/DownloadData.js"></script>
<!-- send data to server -->
<script src="./js/DataTransmitter.js"></script>
<!-- preload font -->
<script>
var fontnamelist = ['lcd', 'digital', 'zorque'];
window.WebFontConfig = {
	custom: {
	        families: fontnamelist,
	        urls: ['./styles/font.css']},
	listeners: [],
	active: function() {
		this.called_ready = true;
		for(var i = 0; i < this.listeners.length; i++) {
			this.listeners[i]();
		}
	},
	ready: function(callback) {
		if (this.called_ready) {
			callback();
		}else {
			this.listeners.push(callback);
		}
	}
};
WebFontConfig.ready(function(){
	FONTLOADED = true;
});
 </script>
<script src="//ajax.googleapis.com/ajax/libs/webfont/1.4.7/webfont.js"></script>


<script type="text/javascript">
// preloading hit images and memory images
var hitimgs = new Array(imgpaths.length);
function preloadHitImgs(idx){
	if(idx >= imgpaths.length){
		getMedia();	// start experiment
		// preloadFonts(0);
		return;
	}
	hitimgs[idx] = new Image();
	hitimgs[idx].onload = function(){
		preloadHitImgs(idx+1);
	};
	hitimgs[idx].src = imgpaths[idx];
}

// preloading gray pig images
var graypigset = new Array(graypigs.length);
function preloadGrayPigs(idx){
	if(idx >= graypigs.length){
		showInstrMsg(instrMsg.loadimg, "#instrmsgP", $(window).width(), $(window).height()*2/3);
		preloadHitImgs(0);
		return;
	}
	graypigset[idx] = new Image();
	graypigset[idx].onload = function(){
		preloadGrayPigs(idx+1);
	};
	graypigset[idx].src = graypigs[idx];
}

// preloading pig images
var pigset = new Array(pigs.length);
function preloadPigs(idx){
	if(idx >= pigs.length){
		preloadGrayPigs(0);
		return;
	}
	pigset[idx] = new Image();
	pigset[idx].onload = function(){
		preloadPigs(idx+1);
	};
	pigset[idx].src = pigs[idx];
}

// preloading icon images
var iconset = new Array(icons.length);
function preloadIcons(idx){
	if(idx >= icons.length){
		showInstrMsg(instrMsg.loadpig, "#instrmsgP", $(window).width(), $(window).height()*2/3);
		preloadPigs(0);
		return;
	}
	iconset[idx] = new Image();
	iconset[idx].onload = function(){
		preloadIcons(idx+1);
	};
	iconset[idx].src = icons[idx];
}

// get user media
function hasGetUserMedia() {
  return !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);
}
navigator.getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
URL = window.URL || window.webkitURL;
var streamVideo = document.createElement('video'); // video stream

function checkServerResponse(){
	serverRequest = requestAnimationFrame(checkServerResponse);
	if(noHITinDB != null){
		cancelAnimationFrame(serverRequest);
		if (noHITinDB == true) { // no more hit
			showInstrMsg(instrMsg.nohit, "#instrmsgP", $(window).width(), $(window).height()/3*2);
		}else{
			showInstrMsg(instrMsg.loadfont, "#instrmsgP", $(window).width(), $(window).height()*2/3);
			loadfontTime = new Date().getTime();
			checkFontPreloader();
		};
	}
}

function checkFontPreloader(){
	fontPreloaderRequest = requestAnimationFrame(checkFontPreloader);
	if(FONTLOADED){
		cancelAnimationFrame(fontPreloaderRequest);
		showInstrMsg(instrMsg.loadicon, "#instrmsgP", $(window).width(), $(window).height()*2/3);
		preloadIcons(0);
	}
}

function getMedia(){
	// instruction: allow camera access
	showInstrMsg(instrMsg.camaccess, "#instrmsgP", $(window).width(), $(window).height()*2/3);
	if (hasGetUserMedia()) {
		navigator.getUserMedia(getUserMediaConstraints, function(stream) {
			// video stream
		    streamVideo.muted = true;
		    streamVideo.volume = 0;
		    streamVideo.autoplay = true;
		    streamVideo.width = hdW;
		    streamVideo.height = hdH;
		    streamVideo.src = URL.createObjectURL(stream);
		    streamVideo.play();
	        localStream = stream;

	        // instruction: allow access to fullscreen
	        showInstrMsg(instrMsg.fullscreen, "#instrmsgP", $(window).width(), $(window).height()*2/3);
	        // set up canvas
	        setUpCanvas();
	        // button: enter full screen mode
	        displayElm2Center('#fullscreenButton', $(window).width(), $(window).height());

	    }, function() {
	        alert('Webcam access is denied.');
	    });
	} else {
		alert('getUserMedia() is not supported in your browser');
	}// getUserMedia
}

// onload document

$(document).ready(function() {
	if(bowser.name != 'Chrome'){ // test web browser: terminate if not google chrome	
		alert(instrMsg.webbrowser);
		// instruction: copy address
		showInstrMsg(instrMsg.copylink, "#instrmsgP", $(window).width(), $(window).height()/3*2);
		// button: copy the current URL to clipboard
		displayElm2Center('#copylinkButton', $(window).width(), $(window).height());
		$("#copylinkButton").zclip({
		path: "./js/ZeroClipboard.swf",
		copy: function(){
				return document.URL;
			}
		});
	}else{
		if (ProcID == 'PX' || ProcID == 'A' || ProcID == 'B' || ProcID == 'C' || ProcID == 'D'){
			checkServerResponse(); // check response from the server
		}else{
			showInstrMsg(instrMsg.loadfont, "#instrmsgP", $(window).width(), $(window).height()*2/3);
			loadfontTime = new Date().getTime();
			checkFontPreloader();
		}
		
	}
}); // document ready

// set up canvas when ready
function setUpCanvas(){
	// screen size
	sW = screen.width;
	sH = screen.height;

	// canvas used for video streaming
	imgCanvas = document.getElementById('imgCanvas');
	imgCanvasCtx = imgCanvas.getContext('2d');
	drawW = imgCanvas.width;
	drawH = imgCanvas.height;

	// overlay canvas: display facial landmarks
	overlay = document.getElementById('overlay');
	overlayCtx = overlay.getContext('2d');

	// overlay canvas: display instruction message
	msgoverlay = document.getElementById('msgoverlay');
	msgoverlayCtx = msgoverlay.getContext('2d');

	// set up canvas to work on tracking: mid resolution
	trackCanvas = document.createElement('canvas');
	trackCanvasCtx = trackCanvas.getContext('2d');
	trackCanvas.width = trckW;
	trackCanvas.height = trckH;

	// set up canvas to work on feature extraction: high resolution
	hdCanvas = document.createElement('canvas');
	hdCanvasCtx = hdCanvas.getContext('2d');
	hdCanvas.width = hdW;
	hdCanvas.height = hdH;

	// full-screen canvas
	fsCanvas = document.getElementById("fullscreen");
	fsCanvas.width = sW;
	fsCanvas.height = sH;
	ctx = fsCanvas.getContext('2d');

	// full-screen overlay canvas
	fsoverlayCanvas = document.getElementById("fsoverlay");
	fsoverlayCtx = fsoverlayCanvas.getContext('2d');
	fsoverlayCanvas.width = sW;
	fsoverlayCanvas.height = sH;
}

// enter full screen
function enterFullScreen(){
	postErrMsg(save_fnmae_err, upload_url_err, 'click enter full screen;');
	ctx.fillStyle = fsmsgBckColor;
	ctx.fillRect(0,0,sW,sH);
	$('#fullscreen').show();

	fsoverlayCtx.clearRect(0, 0, sW, sH); 
	$('#fsoverlay').show();

	// place canvases to correct position
	displayElm2Center('#imgCanvas', sW, sH+cvsshift);
	displayElm2Center('#overlay', sW, sH+cvsshift);
	displayElm2Center('#msgoverlay', sW, sH+cvsshift);
	displayElm2Center('#fsoverlay', sW, sH);
	// place buttons to correct position
	displayElm2Center('#reTrack', sW-drawW/2, sH+drawH+cvsshift+cvsmargin+$('#reTrack').height());
	displayElm2Center('#start', sW+drawW/2, sH+drawH+cvsshift+cvsmargin+$('#start').height());
	$('#fullscreenButton').hide();
	// instruction messages
	$('#instrmsgP').hide();
	// toggle full screen
	toggleFullScreenOnEle("content");
	$(document).bind('keydown', function fn(event) 
	{ 
		if(event.keyCode == 81){ // 'q'
			alert("Quit/Restart the task.");
			$(document).unbind(); // unbind key press event
			KEY_DOWN = true;
			toggleFullScreen();
			postErrMsg(save_fnmae_err, upload_url_err, 'press key to quit;');
			restartTask(instrMsg.restartwork);
		}
	});
	
	setTimeout(function() {checkFullscreenOn();}, 3000); // constantly check fullscreen
	startTracking(); // start facial landmark tracking
}

// check whether fullscreen is on
function checkFullscreenOn(){
	checkFullscreenOnRequest = requestAnimFrame(checkFullscreenOn);
	if(window.innerHeight != screen.height){
	// if(window.outerHeight != screen.height){
		$(document).unbind(); // unbind key press event
		cancelRequestAnimFrame(checkFullscreenOnRequest);
		if (!EXPERIMENT_END && !KEY_DOWN){
			alert("Please keep your browser in fullscreen mode.")
			postErrMsg(save_fnmae_err, upload_url_err, 'quit fullscreen;');
			restartTask(instrMsg.fullscreen); // restart the whole experiment
		}else{
			KEY_DOWN = false;
		}
		$('#instrmsgP').css('color',msgColor);
	}
}

// for full screen
function RunPrefixMethod(obj, method) {
	var p = 0, m, t;
	while (p < pfx.length && !obj[m]) {
		m = method;
		if (pfx[p] == "") {
			m = m.substr(0,1).toLowerCase() + m.substr(1);
		}
		m = pfx[p] + m;
		t = typeof obj[m];
		if (t != "undefined") {
			pfx = [pfx[p]];
			return (t == "function" ? obj[m]() : obj[m]);
		}
		p++;
	}
}
// toggle to normal size
function toggleFullScreen(){
	if (RunPrefixMethod(document, "FullScreen") || RunPrefixMethod(document, "IsFullScreen")) {
		RunPrefixMethod(document, "CancelFullScreen");
	}
	else {
		RunPrefixMethod(document.getElementById("fullscreen"), "RequestFullScreen");
	}
}

// restart the whole experiment
function restartTask(msg){
	RESTART = true; // restart experiment
	// terminate loops
	if (ldmkTrackRequest) cancelRequestAnimFrame(ldmkTrackRequest);
	if (displayLdmkRequest) cancelRequestAnimFrame(displayLdmkRequest);
	if (checkFullscreenOnRequest) cancelRequestAnimFrame(checkFullscreenOnRequest);
	// if ()
	ctrackr.stop(); // face tracker
	if(recorder != null) recorder.stop(); // recorder
	if(rawcarrier != null) rawcarrier.terminate(); // stop sending eye patch data	

	recorder = null;
	KEY_DOWN = false;
	EXPERIMENT_END = false;
	ABTEST = false;

	// hide elements
	$('#eyeCanvas').hide();
	$('#imgCanvas').hide();
	$('#overlay').hide();
	$('#msgoverlay').hide();
	ctx.fillStyle = instrBodyColor;
	ctx.fillRect(0,0,sW,sH);
	$('#reTrack').hide();
	$('#start').hide();
	$('#statusmsgP').hide();
	$('#vismsgP').hide();
	$('#slider').hide();
	$('#fsoverlay').hide();
	$('#fullscreen').css('cursor','default');
	$('#fsoverlay').css('cursor','default');
	$('#instrmsgP').css('cursor','default');
	$('#instrmsgP').css('color',msgColor);
    showInstrMsg(msg, "#instrmsgP", $(window).width(), $(window).height()*2/3);
    if (msg == instrMsg.computertooslow) {
    	$('#quitFullScreenButton').css( "backgroundColor", closeTabBttnColor);
		$('#quitFullScreenButton').prop('disabled', false);
		displayElm2Center('#quitFullScreenButton', $(window).width(), $(window).height());
    }else{
    	$('#fullscreenButton').html('Restart Task');
	    displayElm2Center('#fullscreenButton', $(window).width(), $(window).height());
    }
    cntFPS = 0;
    avgFPS = 0;
}

// toggle a div to fullscreen model
function toggleFullScreenOnEle(ele){
	elem = document.getElementById(ele);
	if (elem.requestFullscreen){
		elem.requestFullscreen();
	} else if (elem.msRequestFullscreen){
		elem.msRequestFullscreen();
	} else if (elem.mozRequestFullScreen){
		elem.mozRequestFullScreen();
	} else if (elem.webkitRequestFullscreen){
		elem.webkitRequestFullscreen();
	}
}

function startTracking(){
	$('#reTrack').prop('disabled', false);
	$('#start').prop('disabled', true);
	// initialize tracker
	ctrackr = new clmpm.tracker({useWebGL : true});
	ctrackr.init(pModel);
	// tracking
	facialLdmkTrackingDisplay();
}

// restart facial landmark tracking
function restartTracking(){
	postErrMsg(save_fnmae_err, upload_url_err, 'click restart tracking;');
	ctrackr.reset();
}

// display facial landmarks tracking results
function facialLdmkTrackingDisplay(){
	displayLdmkRequest = requestAnimFrame(facialLdmkTrackingDisplay);

	imgCanvasCtx.drawImage(streamVideo,0,0,showW,showH); // display the video stream
	trackCanvasCtx.drawImage(streamVideo, 0, 0, trckW, trckH) // rescale the video stream
	ctrackr.trackFrame(trackCanvas); // tracking
	overlayCtx.clearRect(0, 0, showW, showH); // tracking results
	if(ctrackr.getCurrentPosition()){
		ctrackr.draw(overlay);
	}
	// status message
	msgoverlayCtx.clearRect(0, 0, drawW, drawH);
	msgoverlayCtx.fillStyle = statusMsgBarColor;
	msgoverlayCtx.fillRect(0, 0, barw, barh);
	
	var positions = ctrackr.getCurrentPosition(); 
	var msg = checkLdmkValidity(positions);
	var validldmk = false;
	if (msg == ''){
		// check average intesnsity of eye patch
		var leftI = computeAverageIntensity(trackCanvasCtx, positions[23][0], positions[24][1], positions[25][0]-positions[23][0], positions[26][1]-positions[24][1]);
		var rightI = computeAverageIntensity(trackCanvasCtx, positions[30][0], positions[29][1], positions[28][0]-positions[30][0], positions[31][1]-positions[29][1]);
		if(leftI > minIntensity && rightI > minIntensity){
			validldmk = true;
		}else{
			msg = statusMsg.toodark;
		}
	}
	if(validldmk){
		showInstrMsg(statusMsg.clickrestart,"#statusmsgP", sW, sH-showH+cvsshift);
		if(DISPLAYON == false && DISPLAYDOTON == false && ABTEST == false){
			$('#start').prop('disabled', false);
			$('#start').css("backgroundColor", startBttnColor);
		}
	}else{
		$('#start').prop('disabled', true);
		$('#start').css( "backgroundColor", disableBttnColor);
		showInstrMsg(msg, "#statusmsgP", sW, sH-showH+cvsshift);
	}
}

function computeAverageIntensity(ctx, x, y, w, h){
	var imageData = ctx.getImageData(x, y, w, h);
	var pixels = imageData.data;
	var meanval = 0;
	for(var i = 0; i < w*h; i++){
		meanval += pixels[i*4];
		meanval += pixels[i*4+1];
		meanval += pixels[i*4+2];
	}
	return meanval/(w*h*3);
}

// check the quality the facial landmark tracking based on head pose, face size
function checkLdmkValidity(position){
	if(!position){
		return statusMsg.detecting;
	}
	// estimate roll: the direction of the line connecting two outer eye corners
	var Roll = Math.abs(Math.atan((position[28][1]-position[23][1])/(position[28][0]-position[23][0]))/Math.PI*180);
	if(Roll > maxRoll){
		return statusMsg.rotateface;
	}
	// estimate yaw
	// direction of nose bridge (nose, eye, mouth relative location)
	var Yaw = Math.abs(Math.atan((position[33][0]-position[62][0])/(position[33][1]-position[62][1]))/Math.PI*180);
	if(Yaw > maxYaw){
		return statusMsg.turnface;
	}
	// control eye patch size: not too small/large
	var iW = Math.abs(position[23][0]+position[30][0]-position[25][0]-position[28][0])/2;
	if(iW < minEyeW){
		return statusMsg.toofar;
	}
	if(iW > maxEyeW){
		return statusMsg.tooclose;
	}
	return ''; // no abnormal result detected
}

// start experiment
function startTask(){
	RESTART = false;
	postErrMsg(save_fnmae_err, upload_url_err, 'click start task;');
	var positions = ctrackr.getCurrentPosition();
	if (checkLdmkValidity(positions) != ''){return;} 
	// hide cursor
	$('#fullscreen').css('cursor','none');
	$('#fsoverlay').css('cursor','none');
	$('#instrmsgP').css('cursor','none');

	prev_positions = null; // detect rapid change in facial landmark location

	// initialize the histogram extractor: eye width and height
	var ew =  Math.abs(positions[23][0]+positions[30][0]-positions[25][0]-positions[28][0])/2;
	var eh = Math.abs(positions[24][1]+positions[29][1]-positions[26][1]-positions[31][1])/2;
	ew = Math.max(ew, eh/eyepatchratio);
	eh = Math.max(eh, ew*eyepatchratio);

	optionColorhist.pw = ew * colorhistmargin;
	optionColorhist.ph = eh * colorhistmargin; 
	colorhist = new normalizedHist.hist(optionColorhist);
	patchsize[0] = colorhist.patchwidth();
	patchsize[1] = colorhist.patchheight();

	// initialize queue for training, testing, raw data collection
	trainQueue = [], testQueue = [], blankQueue = [], dataQueue = [], detectQueue = [], displayQueue = [], timeQueue = [];
	if(RAWDATA && SEND_DATA){
		// parameters
		var data_item = {"patchsize":patchsize, "margin":margin_raw, "sw":sW, "sh": sH};
		dataQueue.push(data_item);
		// one snapshot
		var snap_shot = trackCanvas.toDataURL('image/jpeg', 0.2);
		dataQueue.push({"snapshot":snap_shot});
		// canvas for eye images
		if($('#eyeCanvas').length > 0){
			$('#eyeCanvas').remove();
		}
		eyeCanvas = document.createElement('canvas');
		eyeCanvas.id = "eyeCanvas";
		eyeCanvas.width = patchsize[0]+2*margin_raw[0];
		eyeCanvas.height = patchsize[1]+2*margin_raw[1];
		eyeCanvas.style = '';
		$('body').append(eyeCanvas);	
		$('#eyeCanvas').hide();
		eyeCanvasCtx = eyeCanvas.getContext('2d');		

		rawcarrier = new transmitdata.DataTransmitter(save_fname_raw, dataQueue, delimiter_raw, bsize_raw, sendinterval_raw);
		rawcarrier.start(false);
	}
	// bilateral setting
    bfilterQ = new Array(bfilterLen);
	bfilterCnt = 0;
	
	// optical flow setting
	opticlflw_para.pw = patchsize[0];
	opticlflw_para.ph = patchsize[1];
	opticlflw_para.w = trckW;
	opticlflw_para.h = trckH;
	opticlflw = new OpticalFlow(opticlflw_idx, opticlflw_mp_idx, positions, opticlflw_para);
	
	// online prediction
	model_online = null;

	if (TEST_STABILIZATION){
		$('#opticalflow').show();
		ofCanvas = document.getElementById('opticalflow');
		// displayElm2Center('#opticalflow', sW, 0);
		ofCanvas.style.position = "absolute";
		displayElm2Center('#opticalflow', sW, sH+cvsshift-200);
		ofCtx = ofCanvas.getContext('2d');
		drawstabilization();
	}else{
		cancelRequestAnimFrame(displayLdmkRequest); // stop display tracking instruction
		// hide elements
		$('#imgCanvas').hide();
		$('#overlay').hide();
		$('#msgoverlay').hide();
		$('#reTrack').hide();
		$('#start').hide();
		$('#statusmsgP').hide();
		$('#instrmsgP').hide();
		// show elements
		ctx.fillStyle = pointBckColor;
		ctx.fillRect(0,0,sW,sH);
		$('#fullscreen').show();

		// initialzie recorder
		recorder = new VideoRecorder(localStream, recordW, recordH);
		ImageData = '';

		// start facial landmark tracking
		ldmktracking();

		// set buffer time for toggling screen to fullsize
		setTimeout(function() {
			recorder.start(); // start recording
			curposdisplay = 0;
			$('#instrmsgP').css('color',fsmsgColor);
			display(expsequence); // start display images on screen
			DISPLAYON = true;
		}, 1000);
	}
}

function ldmktracking(){
	ldmkTrackRequest = requestAnimFrame(ldmktracking);

	var time = new Date().getTime();
    if (lastFrameTimeTrck == null) { lastFrameTime = time;}
    if (time - lastFrameTimeTrck <= trckInterval) return; // control frame rate: 25 ms per frame
    lastFrameTimeTrck = time;

	// var t4 = new Date().getTime();
	trackCanvasCtx.drawImage(streamVideo, 0, 0, trckW, trckH) // rescale the image
	ctrackr.trackFrame(trackCanvas); // tracking
	// console.log('Face tracking: ' + (new Date().getTime()-t4)+'ms')
}

function drawstabilization(){
	requestAnimFrame(drawstabilization);
	var time = new Date().getTime();
    if (lastFrameTimeStb == null) { lastFrameTime = time;}
    if (time - lastFrameTimeStb <= trckInterval) return; // control frame rate: 25 ms per frame
    lastFrameTimeStb = time;

	var positions = ctrackr.getCurrentPosition();
	if(positions){
		hdCanvasCtx.drawImage(streamVideo,0,0,hdW,hdH); // hd image
		// var midpoint = opticlflw.getmidpoint(positions, hdCanvasCtx, hdW, hdH);
		var midpoint = opticlflw.getmidpoint(positions, trackCanvasCtx, trckW, trckH);
		// console.log('L:' + midpoint[0].map(Math.round) + '  R:' + midpoint[1].map(Math.round));

		// without stabilization
		var curr_pos = [[0,0],[0,0]];
	    // averaging
	    for(var e = 0; e < 2; e++){
	    	for(var i = 0; i < opticlflw_mp_idx[0].length; i++){
	    		curr_pos[e][0] += positions[opticlflw_mp_idx[e][i]][0] * scaleW;
		    	curr_pos[e][1] += positions[opticlflw_mp_idx[e][i]][1] * scaleH;	
	    	}
	    	curr_pos[e][0] /= opticlflw_mp_idx[0].length;
	    	curr_pos[e][1] /= opticlflw_mp_idx[0].length;
	    }
		
		var imgdata = new Array(2);
		for(var e = 0; e < 2; e++){
			// optical flow
			// imgdata[e] = hdCanvasCtx.getImageData(midpoint[e][0] - (patchsize[0]-1)/2, midpoint[e][1] - (patchsize[1]-1)/2, patchsize[0], patchsize[1]);
			// original ldmk
			imgdata[e] = hdCanvasCtx.getImageData(curr_pos[e][0] - (patchsize[0]-1)/2, curr_pos[e][1] - (patchsize[1]-1)/2, patchsize[0], patchsize[1]);
		}
		// draw eye image data
		var w = 150, h = 80;
		ofCtx.clearRect(0, 0, ofCtx.width, ofCtx.height); // clear the canvas
		ofCtx.fillStyle = "#FFF";
		ofCtx.fillRect((ofCanvas.width-w)/2,0,w,h);
		ofCtx.strokeStyle = "#FFFF00";
		ofCtx.strokeRect((ofCanvas.width-w)/2,0,w,h);
		
		for(var e = 0; e < 2; e++){
			ofCtx.putImageData(imgdata[e], (w/2-patchsize[0])/2+(ofCanvas.width)/2*e+(ofCanvas.width-w)/2*(1-e), (h-patchsize[1]-4)/2); 
		}

		// bilateral filtering
		bfilterQ.pop();
		var newPos = new Array(2);
		for(var e = 0; e < 2; e++){
			newPos[e] = new Array(2);
			for(var i = 0; i < 2; i++){
				newPos[e][i] = curr_pos[e][i];
			}
		}
		bfilterQ.unshift(newPos);
		if (bfilterCnt < bfilterLen) bfilterCnt++;
		var bfpos = bilateralFilter(bfilterQ, bfilterCnt, bfilter_para);

		var imgdata = new Array(2);
		for(var e = 0; e < 2; e++){
			imgdata[e] = hdCanvasCtx.getImageData(bfpos[e][0] - (patchsize[0]-1)/2, bfpos[e][1] - (patchsize[1]-1)/2, patchsize[0], patchsize[1]);
		}
		// draw eye image data
		for(var e = 0; e < 2; e++){
			ofCtx.putImageData(imgdata[e], (w/2-patchsize[0])/2+(ofCanvas.width)/2*e+(ofCanvas.width-w)/2*(1-e), (h+patchsize[1]+4)/2); 
		}
		// console.log('Fixed L:' + bfpos[0].map(Math.round) + '  R:' + bfpos[1].map(Math.round));

		// test fixed position
		if(jittercnter == -1){
			savejitterloc = new Array(60*2);
			savoploc = new Array(60*2);

			jitterloc = new Array(2);
			for(var e = 0; e < 2; e++){
				jitterloc[e] = new Array(2);
				for(var i = 0; i < 2; i++){
					jitterloc[e][i] = midpoint[e][i];
				}
			}
			jittercnter++;
		}else if(jittercnter > 300){
			jittercnter = -1;
			str = 'original:';
			for(var i = 0; i < savejitterloc.length; i++){
				str += savejitterloc[i] + ',';
			}
			console.log(str);
			str = 'op:';
			for(var i = 0; i < savoploc.length; i++){
				str += savoploc[i] + ',';
			}
			console.log(str);
			str = 'bf:';
			for(var i = 0; i < savoploc.length; i++){
				str += savebfloc[i] + ',';
			}
			console.log(str);
		}else{
			savejitterloc[jittercnter*2+0] = curr_pos[0][0];
			savejitterloc[jittercnter*2+1] = curr_pos[0][1];
			savoploc[jittercnter*2+0] = midpoint[0][0];
			savoploc[jittercnter*2+1] = midpoint[0][1];
			savebfloc[jittercnter*2+0] = bfpos[0][0];
			savebfloc[jittercnter*2+1] = bfpos[0][1];

			jittercnter++;
			/*
			var imgdata = new Array(2);
			for(var e = 0; e < 2; e++){
				imgdata[e] = hdCanvasCtx.getImageData(jitterloc[e][0] - (patchsize[0]-1)/2, jitterloc[e][1] - (patchsize[1]-1)/2, patchsize[0], patchsize[1]);
			}
			// draw eye image data
			for(var e = 0; e < 2; e++){
				ofCtx.putImageData(imgdata[e], (w/2-patchsize[0])/2+(ofCanvas.width)/2*e+(ofCanvas.width-w)/2*(1-e), (h+patchsize[1]+4)/2); 
			}
			*/
			// console.log('Fixed L:' + jitterloc[0].map(Math.round) + '  R:' + jitterloc[1].map(Math.round));
		}

		
	}
}
function bilateralFilter(queue, cnt, para){
	var base = new Array(2);
	for(var e = 0; e < 2; e++) {
		base[e] = new Array(2);	
		for(var i = 0; i < 2; i++){
			base[e][i] = queue[0][e][i];
		}
	}
	if(cnt == 1) return base;

	var pos = new Array(2);
	var normW = new Array(2);
	for(var e = 0; e < 2; e++) {
		normW[e] = 0;
		pos[e] = new Array(2);
		for(var i = 0; i < 2; i++){
			pos[e][i] = 0;
		}
	}
	for(var k = 0; k < cnt; k++){
		for(var e = 0; e < 2; e ++){
			var w = Math.exp(- k*k/para.sigma_t - 
				(Math.pow(base[e][0]-queue[k][e][0],2)+Math.pow(base[e][1]-queue[k][e][1],2))/para.sigma_pos);
			normW[e] += w;
			for(var i = 0; i < 2; i++){
				pos[e][i] += w*queue[k][e][i];
			}
		}
	}	
	for(var e = 0; e < 2; e++){
		for(var i = 0; i < 2; i++){
			pos[e][i] /= normW[e];
		}
	}
	return pos;
}

// display images on screen
function display(sequence){
	if (RESTART){
		DISPLAYON = false;
		return; 
	}
	if (curposdisplay >= sequence.length){ // finish experiment
		curposdisplay++;
		DISPLAYON = false;
		stop();
		return;
	}

	var entry = sequence[curposdisplay];
	$('#instrmsgP').hide();

	// online prediction
	if(curposdisplay > 0 && sequence[curposdisplay].type != "point" && sequence[curposdisplay-1].type == "point"){
		onlineprediction();
	}
	switch(entry.type){
		case "point":
			// still circle
			/*
			ctx.fillStyle = pointBckColor;
			ctx.fillRect(0,0,sW,sH);
			var px = entry.location[0]*sW, py = entry.location[1]*sH, pr = pointRadius;
			drawCircle(ctx, px, py, pr, pointColor, true);
			curposdisplay++;
			setTimeout(function(){display(sequence);}, entry.duration);
			*/
			// changing size circle
			/*
			var step = 30; // step size (ms)
			var duration = sequence[curposdisplay].duration+sequence[curposdisplay+1].duration;
			var ratio = sequence[curposdisplay+1].duration/duration;
			var px = entry.location[0]*sW, py = entry.location[1]*sH;
			var pr_mid = (pointRadius-pointRadiusMid)*ratio+pointRadiusMid;
			curposdisplay++;
			DISPLAYDOTON = true;
			
			drawDynamicCirc(sW, sH, ctx, px, py, pointBckColor, pointColor, duration*(1-ratio), pointRadius, pr_mid, step, function(){
				curposdisplay++;
			drawDynamicCirc(sW, sH, ctx, px, py, pointBckColor, pointColor, duration*ratio, pr_mid, pointRadiusMid, step, function(){
				display(sequence); 
				DISPLAYDOTON = false;
			});
			});	*/
			
			// icon image + changing size circle
			var step = 30; // step size (ms)
			var duration = sequence[curposdisplay].duration+sequence[curposdisplay+1].duration;
			var ratio = sequence[curposdisplay+1].duration/duration;
			var px = entry.location[0]*sW, py = entry.location[1]*sH;
			curposdisplay++;
			DISPLAYDOTON = true;

			ctx.fillStyle = pointBckColor;
			ctx.fillRect(0,0,sW,sH);
			var iconidx = Math.floor(Math.random()*icons.length); // randomly select a bird
			// bird 
			ctx.drawImage(iconset[iconidx], px-iconsize/2, py-iconsize/2, iconsize, iconsize);
			iconsound.play();
			// door and dot
			ctx.lineWidth = ringLineWith;
			drawDynamicRing(ctx, px, py, pointBckColor, pointBckColor, duration*(1-ratio), iconsize*0.75, 0, step, function(){
				curposdisplay++;
				drawDynamicCirc(sW, sH, ctx, px, py, pointBckColor, iconcolor[iconidx], duration*ratio, 0, 10, step, function(){
					display(sequence); 
					DISPLAYDOTON = false;
				});
			});
			break;
		case "image":
			ctx.fillStyle = imgBckColor;
			ctx.fillRect(0,0,sW,sH);
			var idx;
			for(var i = 0; i < numimg; i++){
				if(imgpaths[i] == entry.path){
					idx = i; 
					break;
				}
			}
			image = hitimgs[idx];
			var s = Math.min(sW/image.width, sH/image.height);
			var w = image.width*s, h = image.height*s;
			ctx.drawImage(image, (sW-w)/2, (sH-h)/2, w, h);
			curposdisplay++;
			setTimeout(function(){display(sequence);}, entry.duration);
			break;
		case "cross":
			var px = 0.5*sW, py = 0.5*sH, pr = crossRadius;
			ctx.fillStyle = crossBckColor;
			ctx.fillRect(0,0,sW,sH);
			// draw a cross
			drawCross(ctx, px, py, pr, crossColor, crosslineWidth);
			curposdisplay++;
			setTimeout(function(){display(sequence);}, entry.duration);
			break;
		case "message":
			ctx.fillStyle = fsmsgBckColor;
			ctx.fillRect(0,0,sW,sH);
			showInstrMsg(entry.content, "#instrmsgP", sW, sH-100);
			// if(entry.content.search("</br>")){
			// 	showInstrMsg(entry.content, "#instrmsgP", $(window).width(), $(window).height()-100);
			// }else{}
			curposdisplay++;
			setTimeout(function(){display(sequence);}, entry.duration);
			break;
		case "abtest":
			curposdisplay++;
			fsoverlayCtx.clearRect(0, 0, sW, sH); 
			$('#fsoverlay').show();
			startabtest();
			checkabtest();
			setTimeout(function(){
				if(ABTEST == false){ // program has restarted
					return;
				}else{
					ABTEST = false;
					// check whether all pigs are cleared
					if (cntPig > 0){ // restart experiment: show message
						alert('Time Out!');
						restartTask(instrMsg.timeout);
					}
				}
			}, entry.duration);
			break;
	}
}

function checkabtest(){
	abtestRequest = requestAnimationFrame(checkabtest);
	if(RESTART){
		ABTEST = false;
		DISPLAYON = false;
	}
	if(ABTEST == false){
		cancelAnimationFrame(abtestRequest);	
	}
}
// angry bird: kill pig test
function startabtest(){
	ABTEST = true;
	cntPig = numPig;
	drawPig();
}

function drawPig(){
	ctx.fillStyle = pointBckColor;
	ctx.fillRect(0,0,sW,sH);

	var loc = [Math.random()*0.7+0.15, Math.random()*0.7+0.15]; // random position
	curpigpos = [sW*loc[0], sH*loc[1]];
	curpigidx = Math.floor(Math.random()*pigset.length);
	ctx.drawImage(pigset[curpigidx], curpigpos[0]-pigsize/2, curpigpos[1]-pigsize/2, pigsize, pigsize);
	var x = curpigpos[0]-bloodRectW/2, y = curpigpos[1]-pigsize/2-15;
	var colorgrad=ctx.createLinearGradient(x, y, x+pigsize, y);
	colorgrad.addColorStop(0,"red");
	colorgrad.addColorStop(0.5,"yellow");
	colorgrad.addColorStop(1,"green");
	ctx.fillStyle=colorgrad;
	ctx.fillRect(x, y, bloodRectW, bloodRectH);
	ctx.strokeStyle = bloodRectColor;
	ctx.rect(x, y, bloodRectW, bloodRectH);
	ctx.stroke();
	ctx.closePath();

	hitcountdown = numPigHit;
	lowblood = false;
	ABTEST = true;
}

//video recorder
function VideoRecorder(mediaStream,width,height) {
    this.start = function() {
        canvas.width = this.width;
        canvas.height = this.height;
        video.width = this.width;
        video.height = this.height;
        function drawVideoFrame(time) {
        	lastAnimationFrame = requestAnimationFrame(drawVideoFrame);
            if (curposdisplay > expsequence.length){ // finish experiment
				cancelRequestAnimFrame(lastAnimationFrame);
				cancelRequestAnimFrame(ldmkTrackRequest);
				return;
			}
			if (curposdisplay < 0) return;
            // minimum time interval between two images
            var time = new Date().getTime();
            if (lastFrameTime == null) { lastFrameTime = time;}
            if (time - lastFrameTime <= 25) return; // control frame rate: 25 ms per frame
            // console.log('Frame: '+ (time - lastFrameTime) + 'ms');
            // console.log('fps: '+ 1000/(time - lastFrameTime));

            if (cntFPS <= numFPSframe) {
            	cntFPS++;	
            	avgFPS += 1000/(time - lastFrameTime);
            	if (cntFPS == numFPSframe) {
            		avgFPS /= numFPSframe;
            		if(avgFPS < minFPS){
            			postErrMsg(save_fnmae_err, upload_url_err, instrMsg.computertooslow);
						restartTask(instrMsg.computertooslow);
						return;
            		} // fps is too low
            	};
            }

            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            lastFrameTime = time;

            if (VISUALIZATION == true){ // do not save video if visualizatin is not requested
	            ImageData += time + ';' + canvas.toDataURL('image/jpeg', 0.9).substring(23) + ';'; // record frame
            }
            
            // track face and extract features
            // var t5 = new Date().getTime();
			hdCanvasCtx.drawImage(streamVideo,0,0,hdW,hdH); // hd image
			// console.log('Draw hd: ' + (new Date().getTime()-t5)+'ms')
			
			var positions = ctrackr.getCurrentPosition(); // get landmark location

			// var t6 = new Date().getTime();
			// check the validity of current landmark positions and temporal chagne
			var msg = checkLdmkValidity(positions);
			if (msg != ''){ // stop recorder
				// console.log(msg);
				if (lastAnimationFrame){
					cancelAnimationFrame(lastAnimationFrame);
				}
				if (msg == statusMsg.detecting){
					alert(instrMsg.losttrack);
				}else{
					alert(msg);
				}
				postErrMsg(save_fnmae_err, upload_url_err, 'invalid head pose: ' + msg + ';');
				restartTask(instrMsg.keepstill);
				return;
			}
			// check the location change prev_positions
			if(!prev_stable_pos){
				prev_stable_pos = new Array(stable_idx.length);
				for(var i = 0; i < stable_idx.length; i++){
					prev_stable_pos[i] = new Array(2);
					prev_stable_pos[i][0] = positions[stable_idx[i]][0];
					prev_stable_pos[i][1] = positions[stable_idx[i]][1];
				}
			}else{
				var delta = 0;
				for(var i = 0; i < stable_idx.length; i++){
					delta += Math.sqrt(Math.pow(prev_stable_pos[i][0]-positions[stable_idx[i]][0], 2)+Math.pow(prev_stable_pos[i][1]-positions[stable_idx[i]][1], 2));
				}			
				if(delta/stable_idx.length > stable_th){
					// console.log(delta/stable_idx.length)
					prev_stable_pos = null;
					alert(instrMsg.headmove);
					postErrMsg(save_fnmae_err, upload_url_err, 'abrupt head movement;');
					restartTask(instrMsg.keepstill);
					return;
				}
			}
			// console.log('Check: ' + (new Date().getTime()-t6)+'ms')

			// var t1 = new Date().getTime();
			var feature = {"type":"colorhist", "value":null, "entryidx":curposdisplay-1};
			var eyeloc = [[0,0],[0,0]];
			if(positions){
				detectQueue.push(true); // facial landmark exists
				/*
				// get location [[left_x, left_y],[right_x, right_y]] by optical flow
				var midpoint = opticlflw.getmidpoint(positions, trackCanvasCtx, trckW, trckH);
				*/

				// without stabilization
				var curr_pos = [[0,0],[0,0]];
			    // averaging
			    for(var e = 0; e < 2; e++){
			    	for(var i = 0; i < opticlflw_mp_idx[0].length; i++){
			    		curr_pos[e][0] += positions[opticlflw_mp_idx[e][i]][0] * scaleW;
				    	curr_pos[e][1] += positions[opticlflw_mp_idx[e][i]][1] * scaleH;	
			    	}
			    	curr_pos[e][0] /= opticlflw_mp_idx[0].length;
			    	curr_pos[e][1] /= opticlflw_mp_idx[0].length;
			    }

				// bilateral filtering
				bfilterQ.pop();
				var newPos = new Array(2);
				for(var e = 0; e < 2; e++){
					newPos[e] = new Array(2);
					for(var i = 0; i < 2; i++){
						newPos[e][i] = curr_pos[e][i];
					}
				}
				bfilterQ.unshift(newPos);
				if (bfilterCnt < bfilterLen) bfilterCnt++;
				var midpoint = bilateralFilter(bfilterQ, bfilterCnt, bfilter_para);

				for(var e = 0; e < 2; e++){
					for(var d = 0; d < 2; d++){
						eyeloc[e][d] = midpoint[e][d] - (patchsize[d]-1)/2;
					}
				}
				feature.value = new Array(2);
				for(var e = 0; e < 2; e++){
					feature.value[e] = colorhist.getfeature(hdCanvasCtx, eyeloc[e][0], eyeloc[e][1]);
				}
				// sending to server: save to queue
			}else{
				detectQueue.push(false); // facial landmark not exists
			}
			// console.log('Feature extraction: '+ (new Date().getTime() -t1) + 'ms');

			// var t2 = new Date().getTime();
			if (RAWDATA && SEND_DATA){ // raw data collector: save eye patch
				// eye image webp
				var eyepatch = new Array(2);
				if(positions){
					for(var e = 0; e < 2; e++){
						// get image
						var imgdata = hdCanvasCtx.getImageData(eyeloc[e][0]-margin_raw[0], eyeloc[e][1]-margin_raw[1], patchsize[0]+2*margin_raw[0], patchsize[1]+2*margin_raw[1]);
						// put to a canvas
						eyeCanvasCtx.putImageData(imgdata,0,0);
						// image encoder
						eyepatch[e] = eyeCanvas.toDataURL('image/jpeg', webp_quality); // image url 
					}
				}
				var data_item = {"eyepatch":eyepatch, "position":positions, "eyepos": eyeloc};
				if(!((COMPACTDATA == true)&&(expsequence[curposdisplay-1].tag == "blank"))){
					dataQueue.push(data_item);
				}
			}

			// data collector
			var entry = expsequence[curposdisplay-1];
			if(feature.value == null){
				blankQueue.push(feature);
				displayQueue.push({'type':entry.tag, 'index': blankQueue.length-1});
			}else{
				switch(entry.tag){
					case "train":
						trainQueue.push(feature);	
						displayQueue.push({'type':entry.tag,'index': trainQueue.length-1});
						break;
					case "test":
						testQueue.push(feature);
						displayQueue.push({'type':entry.tag, 'index': testQueue.length-1});
						break;
					case "blank":
						blankQueue.push(feature);
						displayQueue.push({'type':entry.tag, 'index': blankQueue.length-1});
						break;
				}

				if(model_online != null){
					var q = [];
					q.push(feature);
					p = mlmodel_online.predict(q, expsequence, model_online, false); // prediction
					if (p != null){
						x = p.prediction.data[0]*sW;
						y = p.prediction.data[1]*sH;

						if(SHOWONLINE && !ABTEST){
							fsoverlayCtx.clearRect(0, 0, sW, sH); 
							drawCrossHair(fsoverlayCtx, x, y, crosshairRadius, '#0F0', crosshairCircW, crosshairCrsW);
						}
						
						if(ABTEST){ // angry bird test
							// draw cross hair
							fsoverlayCtx.clearRect(0, 0, sW, sH); 
							drawCrossHair(fsoverlayCtx, x, y, crosshairRadius, '#0F0', crosshairCircW, crosshairCrsW);
							var d = Math.max(Math.abs(x-curpigpos[0]), Math.abs(y-curpigpos[1]));
							if (d < pigsize*0.5){
								hitcountdown--;
								// draw cross hair
								fsoverlayCtx.clearRect(0, 0, sW, sH); 
								drawCrossHair(fsoverlayCtx, x, y, crosshairRadius, '#F00', crosshairCircW, crosshairCrsW);
								var x = curpigpos[0]-bloodRectW/2, y = curpigpos[1]-pigsize/2-15;
								ctx.fillStyle = pointBckColor;
								var w = hitcountdown/numPigHit * bloodRectW;
								ctx.fillRect(x+w, y, bloodRectW-w, bloodRectH);
								ctx.strokeStyle = bloodRectColor;
								ctx.beginPath();
								ctx.rect(x, y, bloodRectW, bloodRectH);
								ctx.stroke();
								if(lowblood == false && (hitcountdown/numPigHit) <= lowbloodTh){
									ctx.drawImage(graypigset[curpigidx], curpigpos[0]-pigsize/2, curpigpos[1]-pigsize/2, pigsize, pigsize);
									lowblood = true;
								}

								if(hitcountdown <= 0){
									cntPig--;
									pigsound.play();
									if(cntPig > 0){
										ABTEST = false;
										drawPig();
									}else{
										ABTEST = false;
										if(!SHOWONLINE){
											$('#fsoverlay').hide();	
										}
										display(expsequence); // start real experiment	
									}
								}

							}
						}
					}

				}
			}
			// console.log('Collect data: ' + (new Date().getTime() - t2) + 'ms')
			timeQueue.push(new Date().getTime()); // time stamp
        }
        lastAnimationFrame = requestAnimationFrame(drawVideoFrame);
    };
    this.stop = function(callback) {
        if (lastAnimationFrame) { cancelAnimationFrame(lastAnimationFrame);}
        if (callback){callback();}    
    };
    this.width = width;
    this.height = height;
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    var video = document.createElement('video');
    video.muted = true;
    video.volume = 0;
    video.autoplay = true;
    video.src = URL.createObjectURL(mediaStream);
    video.play();
    var lastAnimationFrame = null;
    var lastFrameTime;
};

// online regression
function onlineprediction(){
	mlmodel_online = new MLModel.mlmodel(learning_para);
	model_online = mlmodel_online.train(trainQueue, expsequence); // train model
}

// finish experiment
function stop(){
	$(document).unbind(); // unbind key press event
	// cancelRequestAnimFrame(checkFullscreenOnRequest);
	// toggleFullScreen();
	EXPERIMENT_END = true;
	localStream.stop(); // stop web cam
	estimategaze();	// gaze estimation

	if(MemTest){ // add memorability test
		/*
		var imgpath;
		if(Math.random() > 0.5 || ProcID == 'TEST'){// new image
			imgpath = imgpaths[numimg];
			mem_ans = false;
		}else{// old image
			var k = Math.round(Math.random()*numimg);
			if (k >= numimg) k = numimg - 1;
			imgpath = imgpaths[k];
			mem_ans = true;
		}
		memorytest(imgpath);
		*/
		ctx.clearRect(0, 0, sW, sH); 
		ctx.fillStyle = imgBckColor;
		ctx.fillRect(0,0,sW,sH);
		fsoverlayCtx.clearRect(0, 0, sW, sH); 
		$('#fullscreen').show();
		$('#fsoverlay').show();
		$('#fullscreen').css('cursor','default');
		$('#fsoverlay').css('cursor','default');
		$('#instrmsgP').css('cursor','default');
		$('#instrmsgP').css('color',fsmsgColor);
		memorytestpreview()
		
	}else{
		senddata();
	}
}
function senddata(){
	if (SEND_DATA){
		$('#instrmsgP').css('color',fsmsgColor);
		showInstrMsg(instrMsg.waitdata2server, "#instrmsgP", $(window).width(), $(window).height()/3);	
	}
	$('#fullscreen').hide();
	$('#fsoverlay').hide();
	$('#instrmsgP').css('cursor','auto');

	if (VISUALIZATION){ // visualization
		// imgCanvasCtx.clearRect(0,0,drawW,drawH);
		imgCanvasCtx.fillStyle = visBlankBckColor;
		imgCanvasCtx.fillRect(0,0,drawW,drawH);
		imgCanvasCtx.fill();
		imgCanvasCtx.strokeStyle = visBlankFrmColor;
		imgCanvasCtx.strokeRect(0,0,drawW,drawH);
		imgCanvasCtx.stroke();
		overlayCtx.clearRect(0,0,drawW,drawH);
		$('#imgCanvas').show();
		$('#overlay').show();
		displayElm2Center('#replayButton', sW-drawW/2, sH+drawH+cvsshift+cvsmargin+$('#replayButton').height());
	}
	if (!VISUALIZATION){
		$('#quitFullScreenButton').css( "backgroundColor", closeTabBttnColor);
		$('#quitFullScreenButton').prop('disabled', false);
		displayElm2Center('#quitFullScreenButton', $(window).width(), $(window).height());
	}

	resultQueue = new Array(displayQueue.length);
	for(var i = 0; i < resultQueue.length; i++){
		var predict_val = null;
		var n = displayQueue[i].index, entryidx;
		switch(displayQueue[i].type){
			case "train":
				entryidx = trainQueue[n].entryidx
				if(train_result != null) predict_val = [train_result.prediction.data[2*n],train_result.prediction.data[2*n+1]];
				break;
			case "test":
				entryidx = testQueue[n].entryidx;
				if(test_result != null) predict_val = [test_result.prediction.data[2*n],test_result.prediction.data[2*n+1]];
				break;
			case "blank":
				entryidx = blankQueue[n].entryidx;
				break;
			default:
				break;
		}
		var data_item = {'index': entryidx,'time':timeQueue[i],'value': predict_val};
		resultQueue[i] = data_item;
	}
	saveQueue = []; // data to download
	saveQueue.push({'patchsize':patchsize, 'margin':margin_raw, 'screenw': sW, 'screenh':sH, 'IPaddress':IPaddress}); //raw data parameter 
	saveQueue.push(expsequence); // experiment configuration
	saveQueue.push(resultQueue); // time stamp, prediction 
	var trainerr = null, testerr = null, looerr_train = null, looerr_test = null;
	if (train_result != null) trainerr = train_result.error;
	if (test_result != null) testerr = test_result.error;
	if (looerr != null){
		looerr_train = JSON.stringify(looerr.train);
		looerr_test = JSON.stringify(looerr.test);	
	} 

	saveQueue.push({'trainerr':trainerr, 'testerr':testerr, 'looerr_train':looerr_train, 'looerr_test':looerr_test});
	saveQueue.push(memActionQueue); // memory test action, time stamp

	// download to local file
	if (DOWNLOAD_DATA){
		displayElm2Center('#downloadButton', sW+drawW/2, sH+drawH+cvsshift+cvsmargin+$('#downloadButton').height());
		$('#downloadButton').prop('disabled', false); 
	}
	// send data to server
	if (SEND_DATA){
		var sendQueue = new Array(1);
		sendQueue[0] = saveQueue;
		resultcarrier = new transmitdata.DataTransmitter(save_fname_result, sendQueue, delimiter, bsize, sendinterval);
		if(RAWDATA){
			rawcarrier.lastbatch(); // finish feeding eye patch data	
		} 
		resultcarrier.start(true);// one shot
		if (looerr != null){ // update performance log
			var meanerr = 0;
			for(var i = 0; i < looerr.test.length; i++){
				meanerr += looerr.test[i];
			}
			meanerr /= looerr.test.length;
			completion_code = 1000 - Math.round(10000*meanerr);
			updatePerformance(meanerr);
		}else{
			updatePerformance(null);
		}
		showTransmitProgress();
	}else{
		$('#instrmsgP').css('color',fsmsgColor);
		showInstrMsg("Congratulations! </br></br> You have completed the training task.", "#instrmsgP", $(window).width(), $(window).height()/4);

		$('#quitFullScreenButton').css( "backgroundColor", closeTabBttnColor);
		$('#quitFullScreenButton').prop('disabled', false);
	}
}

// memory test
function memorytest(){
	MEMTESTPREVIEW = false;
	showInstrMsg('Please select images that you have seen in this HIT', "#instrmsgP", numgrids[1]*(gridspacing+gridsize[1])+gridx*2, gridy);
	$('#memscore').html('0');
	$('#memscore').css({"font-family":"digital", "color": "#F00", "font-size": "100px"});

	$('#bestmemscore').html('BEST SCORE : ' + bestpastscore);
	$('#bestmemscore').css({"font-family":"digital", "color": "#DB9900", "font-size": "20px"});
	$('#memtestButton').prop('disabled', false);
	var x = $('#fsoverlay').width() + numgrids[1]*(gridspacing+gridsize[1])+gridx; 
	displayElm2Center('#memscore', x, $('#fsoverlay').height()/2);
	displayElm2Center('#bestmemscore', x, $('#fsoverlay').height()/2+150*2);
	displayElm2Center('#memtestButton', x, $('#fsoverlay').height());

	var memshowidx = nchoosekRandom(numimg, numshown);
	for(var i = numimg; i < hitimgs.length; i++){
		memshowidx.push(i);
	}
	var memdispidx = nchoosekRandom(numgrids[0]*numgrids[1], numgrids[0]*numgrids[1]);
	var cnt = 0;
	gridsel = new Array(numgrids[0]); //  status: checked/unchecked
	gridmark = new Array(numgrids[0]); // mark
	gridimgs = new Array(numgrids[0]); // image index
	for(var i = 0; i < numgrids[0]; i++){
		gridsel[i] = new Array(numgrids[1]);
		gridmark[i] = new Array(numgrids[1]);
		gridimgs[i] = new Array(numgrids[1]);
		for(var j = 0; j < numgrids[1]; j++){
			gridsel[i][j] = 0;
			gridmark[i][j] = 0;
			gridimgs[i][j] = memshowidx[memdispidx[cnt++]];
		}
	}
	gridselans = new Array(numgrids[0]); // ground truth grid
	for(var i = 0; i < numgrids[0]; i++){
		gridselans[i] = new Array(numgrids[1]);
		for(var j = 0; j < numgrids[1]; j++){
			gridselans[i][j] = 0;
			for(var k = 0; k < numshown; k++){
				if(gridimgs[i][j] == memshowidx[k]){
					gridselans[i][j] = 1;
					break;
				}
			}
		}
	}
	gridloc = getgridloc(0, 0, [10,10], numgrids, 5);
	drawGrids(ctx, gridx, gridy, gridloc, [5,5], gridselans, gridselans, gridColor, selgridColor, 5, 5);
	gridloc = getgridloc(gridx, gridy, gridsize, numgrids, gridspacing);
	drawGrids(fsoverlayCtx, gridx, gridy, gridloc, gridsize, gridsel, gridselans, gridColor, selgridColor, gridLineWidth, selLineWidth);
	drawGridsImg(ctx, gridloc, gridsize, null);
	memActionQueue = [];
	var item = {'imgpaths': imgpaths, 'numgrids': numgrids, 'numshown':numshown, 'shownimgidx':memshowidx, 'imgorder':gridimgs, 'gridselans':gridselans, 'basemark':basemark, 'stepmark':stepmark, 'penaltymark':penaltymark, 'gridimgs':gridimgs};
	memActionQueue.push(item);
	memtestStartTime = new Date().getTime();
	item = {'action': 'start','time':memtestStartTime};
	memActionQueue.push(item);
	MEMTESTON = true;
	setTimeout(function(){
		if(MEMTESTON == false) return; // already submitted
		alert('Time Out!');
		MEMTESTON = false;
	}, memetesTimeLimit);
}

function nchoosekRandom(n, k){
	var idx = new Array(n);
	var ind = new Array(n);
	for(var i = 0; i < n; i++){
		idx[i] = i;
		ind[i] = false
	} 
	var loc = new Array(k);
	for(var i = 0; i < k; i++){
		var r = Math.floor(Math.random()*(n-i));
		var cnt = -1;
		for(var j = 0; j < n; j++){
			if(ind[j] == false){
				cnt++;
				if(cnt == r){
					ind[j] = true;
					loc[i] = j;
					break;
				}
			}
		}
	}
	return loc;
}

/*
function submitMemTest(){
	if ($( "input:radio[name=mem_ans]:checked").length == 0){
		alert('Please answer the question by selecting "yes" or "no".');
	}else{
		mem_reply = $( "input:radio[name=mem_ans]:checked").val();
		$('#memtestform').hide();
		senddata();
	}
}
*/

function getPosition(event){
	if(MEMTESTON == false) return;
	var cx = event.x;
	var cy = event.y;
	cx -= fsoverlayCanvas.offsetLeft;
	cy -= fsoverlayCanvas.offsetTop;
	// select picked image
	var idx = null;
	for(var i = 0; i < numgrids[0]; i++){
		for(var j = 0; j < numgrids[1]; j++){
			var x = gridloc[i][j][0];
			var y = gridloc[i][j][1];
			var w = gridsize[1], h = gridsize[0];
			if(cx >= x && cx <= x+w && cy >= y && cy <= y+h){
				idx = [i,j];
			}
		}
	}
	if(idx != null){
		var t = new Date().getTime();
		var item = {'action': 'click','time':t,'grididx': idx};
		memActionQueue.push(item);
		gridsel[idx[0]][idx[1]] = 1 - gridsel[idx[0]][idx[1]]; // flip status
		// update grids
		fsoverlayCtx.clearRect(0, 0, $('#fsoverlay').width(), $('#fsoverlay').height()); 
		drawGrids(fsoverlayCtx, gridx, gridy, gridloc, gridsize, gridsel, gridselans, gridColor, selgridColor, gridLineWidth, selLineWidth);
		// update game score
		var mark;
		var color;
		var t = new Date().getTime();
		if(gridsel[idx[0]][idx[1]] == 1 && gridselans[idx[0]][idx[1]] == 1){
			mark = basemark - stepmark * Math.floor((t - memtestStartTime)/1000);
			gridmark[idx[0]][idx[1]] = mark;
			color = "#94FA3A";
			truesound.play();
		}
		if(gridsel[idx[0]][idx[1]] == 0 && gridselans[idx[0]][idx[1]] == 1){
			mark = -gridmark[idx[0]][idx[1]];
			gridmark[idx[0]][idx[1]] = 0;
			color = "#F77207";
		}
		if(gridsel[idx[0]][idx[1]] == 0 && gridselans[idx[0]][idx[1]] == 0){
			mark = penaltymark;
			gridmark[idx[0]][idx[1]] += penaltymark;
			color = "#18B8C9";
		}
		if(gridsel[idx[0]][idx[1]] == 1 && gridselans[idx[0]][idx[1]] == 0){
			mark = -penaltymark - stepmark * Math.floor((t - memtestStartTime)/1000);
			gridmark[idx[0]][idx[1]] = mark;
			color = "#F52600";
			falsesound.play();
		}
		var str = mark.toString();
		if(mark > 0) str = '+' + str;	
		$('#memmark').css('color', color);
		$('#memmark').html(str);
		displayElm2Center('#memmark', numgrids[1]*(gridspacing+gridsize[1])+gridx*2,  numgrids[0]*(gridspacing+gridsize[0])+gridy);

		var s = 0;
		for(var i = 0; i < numgrids[0]; i++){
			for(var j = 0; j < numgrids[1]; j++){
				s += gridmark[i][j];
			}
		}
		$('#memscore').html(s);
		var x = $('#fsoverlay').width() + numgrids[1]*(gridspacing+gridsize[1])+gridx; 
		displayElm2Center('#memscore', x, $('#fsoverlay').height()/2);

		setTimeout(function(){
			$('#memmark').hide();
		}, 300);
	}
}

function startMemTest(){
	$('#startmemtestButton').hide();
	$("#fsoverlay").toggleClass("op80");
	setTimeout(function(){
		$("#fsoverlay").toggleClass("op60");
		setTimeout(function(){
			$("#fsoverlay").toggleClass("op40");
			setTimeout(function(){
				fsoverlayCtx.clearRect(0, 0, $('#fsoverlay').width(), $('#fsoverlay').height()); 
				fsoverlayCanvas.addEventListener("mousedown", getPosition, false); // mouse click event
				memorytest();

			}, 150);
		}, 150);
	}, 150);
}

function memorytestpreview(){
	MEMTESTPREVIEW = true;
	showInstrMsg(instrMsg.startmemtest, "#instrmsgP", numgrids[1]*(gridspacing+gridsize[1])+gridx*2, gridy);

	var x = $('#fsoverlay').width() + numgrids[1]*(gridspacing+gridsize[1])+gridx; 
	$('#memscore').html('0');
	$('#memscore').css({"font-family":"digital", "color": "#F00", "font-size": "100px"});

	$('#bestmemscore').html('BEST SCORE : ' + bestpastscore);
	$('#bestmemscore').css({"font-family":"digital", "color": "#DB9900", "font-size": "20px"});
	
	displayElm2Center('#memscore', x, $('#fsoverlay').height()/2);
	displayElm2Center('#bestmemscore', x, $('#fsoverlay').height()/2+150*2);
	displayElm2Center('#startmemtestButton', x, $('#fsoverlay').height());
	
	gridsel = new Array(numgrids[0]); 
	gridimgs = new Array(numgrids[0]); // image index
	for(var i = 0; i < numgrids[0]; i++){
		gridsel[i] = new Array(numgrids[1]);
		gridimgs[i] = new Array(numgrids[1]);
		for(var j = 0; j < numgrids[1]; j++){
			gridsel[i][j] = 0;
			gridimgs[i][j] = Math.floor(Math.random()*(iconset.length));
		}
	}
	gridloc = getgridloc(gridx, gridy, gridsize, numgrids, gridspacing);
	drawGridsImg(fsoverlayCtx, gridloc, gridsize, null);
	drawGrids(fsoverlayCtx, gridx, gridy, gridloc, gridsize, gridsel, gridsel, gridColor, selgridColor, gridLineWidth, selLineWidth);
}

function submitMemTest(){
	var t = new Date().getTime();
	var item = {'action': 'submit','time':t};
	memActionQueue.push(item);
	MEMTESTON = false;
	fsoverlayCanvas.removeEventListener("mousedown", getPosition, false); // mouse click event

	var t = new Date().getTime();
	var mark = 0;
	var cnt = 0; // number of correct selection
	var s = 0; // total score
	for(var i = 0; i < numgrids[0]; i++){
		for(var j = 0; j < numgrids[1]; j++){
			s += gridmark[i][j];
			if(gridsel[i][j] == 1 && gridselans[i][j] == 1) cnt++;
		}
	}
	if(memetesTimeLimit - (t-memtestStartTime) > 0 && cnt > 0){
		mark = stepmark * Math.floor((memetesTimeLimit - (t-memtestStartTime)) / 1000) * cnt;
	}
	s += mark;
	memtestscore = s;
	var str = mark.toString();
	if(mark > 0) str = '+' + str;	
	str = 'BONUS: ' + str;
	var color = "#8925D0";
	$('#memmark').css('color', color);
	$('#memmark').html(str);
	displayElm2Center('#memmark', numgrids[1]*(gridspacing+gridsize[1])+gridx*2,  numgrids[0]*(gridspacing+gridsize[0])-gridspacing+gridy);
	var t = new Date().getTime();
	var item = {'gridsel':gridsel, 'memtestscore':memtestscore,'gridmark':gridmark, 'bonus':mark};
	memActionQueue.push(item);

	$('#memscore').html(s);
	$('#memscore').show();
	setTimeout(function(){
		var color = "#8925D0";
		$('#memmark').css('color', color);
		$('#memmark').html('Congratulations!</br>You have beaten XX% players in the world!');
		displayElm2Center('#memmark', numgrids[1]*(gridspacing+gridsize[1])+gridx*2,  numgrids[0]*(gridspacing+gridsize[0])-gridspacing+gridy);
		$('#fsoverlay').toggleClass('op95');
		fsoverlayCtx.fillStyle = '#A4A4A4';
		fsoverlayCtx.fillRect(0, 0, $('#fsoverlay').width(), $('#fsoverlay').height()); 
		drawGrids(fsoverlayCtx, gridx, gridy, gridloc, gridsize, gridsel, gridsel, gridColor, selgridColor, gridLineWidth, selLineWidth);
		$('#memtestButton').hide();
		$('#finishmemtestButton').prop('disabled', false);
		var x = $('#fsoverlay').width() + numgrids[1]*(gridspacing+gridsize[1])+gridx; 
		displayElm2Center('#finishmemtestButton', x, $('#fsoverlay').height());
	}, 600);
}

function finishMemTest(){
	$('#memmark').hide();
	$('#memscore').hide();
	$('#bestmemscore').hide();
	$('#finishmemtestButton').hide();
	senddata();
}

// monitor sending progress
function showTransmitProgress(){
	monitorDownload(); 
	drawslider(1, 0); // draw progress bar
	displayElm2Center("#slider", $(window).width(), $(window).height()/3*2);
	$('#slider').show();
}

// task is completed
function complete(){
	$('#slider').hide();
	$('#eyeCanvas').hide();

	if (ProcID == 'qualification'){
		$('#instrmsgP').css('color',fsmsgColor);
		showInstrMsg(instrMsg.finishqt, "#instrmsgP", $(window).width(), $(window).height()/4);
	}else{
		var str = 'Congratulations that you have beaten XX% players in the world!';
		str += '</br></br>';
		if(window.innerHeight != screen.height){
			$('#instrmsgP').css('color',msgColor);	
		}else{
			$('#instrmsgP').css('color',fsmsgColor);	
		}
		showInstrMsg(str + instrMsg.finishngo , "#instrmsgP", $(window).width(), $(window).height()/4);

		$('#copylinkButton').css( "backgroundColor", copyBttnColor);
		$('#copylinkButton').html('Copy Your Completion Code to Clipboard');
		displayElm2Center('#copylinkButton', $(window).width(), $(window).height()/5*4);
		$("#copylinkButton").zclip({
		path: "./js/ZeroClipboard.swf",
		copy: function(){
				return completion_code;
			}
		});
	}
	if(window.innerHeight == screen.height){
		$('#quitFullScreenButton').css( "backgroundColor", closeTabBttnColor);
		$('#quitFullScreenButton').prop('disabled', false); // toggle fullscreen
		displayElm2Center('#quitFullScreenButton', $(window).width(), $(window).height());	
	}else{
		$('#quitFullScreenButton').hide();
	}
}

function updatePerformance(score){
	if (score == null){
		scoreUpdate = true;
		return;
	}
	var item = {"calibration_score":score, "memorytest_score":memtestscore};
	workerlog[experimentId].push(item);
	workerlogurl = "http://vision.princeton.edu/projects/2014/iSUN/mturk/save.cgi?";
	$.post(workerlogurl,
	{   file: workerlogname,
	  data: JSON.stringify(workerlog)
	},function(data){
	try{
	  if(data == 'success'){
	    scoreUpdate = true;
	  }else{
	    scoreUpdate = true;
	  }
	}catch(err){
	}
	});
}

// monitor sending progress
function monitorDownload(){
	var s = resultcarrier.progress();
	var sraw = {"status":"Finished", "percent":100};
	if (RAWDATA) sraw = rawcarrier.progress();
	drawslider(100, Math.min(s.percent, sraw.percent)); // draw progress bar
	// console.log(s);
	if (s.status != 'Finished' || sraw.status != 'Finished' || scoreUpdate != true){
		setTimeout(function(){monitorDownload();},sendinterval);
	}else{
		complete(); // task is completed
	}
}

// progress bar
function drawslider(max_progress, cur_progress){
    var percent_progress = Math.round((cur_progress*100)/max_progress);
    document.getElementById("sliderbar").style.width = percent_progress + '%';
    document.getElementById("progress").innerHTML = percent_progress + '%';
}

// download to local file
function download(){
	var datatosave = JSON.stringify(saveQueue);
	DownloadData(datatosave, download_fname);	
}

// train model and estimate gaze
function estimategaze(){
	mlmodel = new MLModel.mlmodel(learning_para);
	model = mlmodel.train(trainQueue, expsequence); // train model
	train_result = mlmodel.predict(trainQueue, expsequence, model, true);
	test_result = mlmodel.predict(testQueue, expsequence, model, true); // prediction

	// cross validation LOO test
	looerr = mlmodel.crossvalidation(trainQueue, expsequence, model, kfold);
	/*
	console.log('loo error: ' + looerr.test);
	console.log('loo error (train): ' + looerr.train);
	*/
}

function visReset(){
	dataPos = 0;
	currVisFrameNum = 0;
	lastShowFrameTime = null;
	smlH = smlW/sW*sH;
	$('#replayButton').prop('disabled', true);
	$('#replayButton').css( "backgroundColor", disableBttnColor);
	visualize();
	
}

// visualize gaze estimation
function visualize(){
	visualRequest = requestAnimationFrame(visualize);
	var time = new Date().getTime();
	if (lastShowFrameTime == null) lastShowFrameTime = time;
    if(time - lastShowFrameTime <= 30) return; // control frame rate: ~30 ms per frame
    lastShowFrameTime = time;

    var frame = getNextFrame();

    if (frame != ''){
    	var imgX = new Image;
        imgX.onload = function(){
        	imgCanvasCtx.drawImage(imgX,0,0,showW,showH); // display the image
            showInstrMsg("Your Screen", "#vismsgP", sW-drawW+smlx*2+smlW, sH-showH+cvsshift+smly/2);
			// small window frame
            imgCanvasCtx.fillStyle = smlBckColor;
            imgCanvasCtx.fillRect(smlx, smly, smlW, smlH);
            overlayCtx.clearRect(0, 0, showW, showH);
            overlayCtx.lineWidth = smlLineWidth;
            overlayCtx.strokeStyle = smlFrameColor;
            overlayCtx.strokeRect(smlx-1, smly-1, smlW+2, smlH+2);

        	// display images
        	var mlentry = displayQueue[currVisFrameNum];
        	var n = mlentry.index, entry;
        	var predict_val = null;
        	// get content
        	switch(mlentry.type){
        		case "train":
	        		entry = expsequence[trainQueue[n].entryidx];
	        		if(train_result!=null) predict_val = [train_result.prediction.data[2*n],train_result.prediction.data[2*n+1]];
	        		break;
        		case "test":
	        		entry = expsequence[testQueue[n].entryidx];
	        		if(test_result!=null) predict_val = [test_result.prediction.data[2*n],test_result.prediction.data[2*n+1]];
	        		break;
        		case "blank":
	        		entry = expsequence[blankQueue[n].entryidx];
	        		break;
        	}
        	// draw display content
        	switch(entry.type){
        		case "point":
        			overlayCtx.fillStyle = pointBckColor;
					overlayCtx.fillRect(smlx,smly,smlW,smlH);
					var px = entry.location[0]*smlW+smlx, py = entry.location[1]*smlH+smly, pr = smlPntRadius;
					drawCircle(overlayCtx, px, py, pr, pointColor, true);
	        		break;
        		case "image":
        			if(cursmlImgSrc!= null && cursmlImgSrc==entry.path){
        				var s = Math.min(smlW/image.width, smlH/image.height);
						var w = image.width*s, h = image.height*s;
	                    imgCanvasCtx.drawImage(image, smlx+(smlW-w)/2, smly+(smlH-h)/2, w, h);
        			}else{
        				cancelRequestAnimFrame(visualRequest);
        				image = new Image();	
		                image.onload = function() {
		                	cursmlImgSrc = image.src;
		                    var s = Math.min(smlW/image.width, smlH/image.height);
							var w = image.width*s, h = image.height*s;
		                    imgCanvasCtx.drawImage(image, smlx+(smlW-w)/2, smly+(smlH-h)/2, w, h);
		                    visualRequest = requestAnimationFrame(visualize);
		                }
		                image.src = entry.path;
        			}
	        		break;
        		case "cross":
        			var px = 0.5*smlW+smlx, py = 0.5*smlH+smly, pr = smlCrxRadius;
					overlayCtx.fillStyle = crossBckColor;
					overlayCtx.fillRect(smlx,smly,smlW,smlH);
					// draw a cross
					drawCross(overlayCtx, px, py, pr, crossColor, smlCrxLineWidth);
	        		break;
        	}
        	// show prediction results
        	if (predict_val != null){
        		var px = predict_val[0]*smlW+smlx, py = predict_val[1]*smlH+smly, pr = smlPntRadius;
        		if (entry.tag == 'train'){
					drawCircle(overlayCtx, px, py, pr, predPntColor, false);	
				}else{
					drawCircle(overlayCtx, px, py, pr, predPntColorTest, false);		
				}
        	}
        	currVisFrameNum++;
        	// visualRequest = requestAnimationFrame(visualize);
        }
        imgX.src = 'data:image/jpeg;base64,'+frame;
    }else{
    	if(visualRequest != null) cancelRequestAnimFrame(visualRequest);
    	$('#replayButton').prop('disabled', false);
		$('#replayButton').css( "backgroundColor", visBttnColor);
		alert('End of the Video');
    }
}

// draw a circle
function drawCircle(context, x, y, r, color, fill){
	context.beginPath();
	context.arc(x, y, r, 0, 2 * Math.PI, true);
	context.closePath();
	if(fill){
		context.fillStyle = color;
		context.fill();	
	}else{
		context.strokeStyle = color;
		context.stroke();
	}
}

// draw a crosshair
function drawCrossHair(context, x, y, r, color, circW, crsW){
	context.beginPath();
	context.lineWidth = circW;
	context.arc(x, y, r, 0, 2 * Math.PI, true);
	context.closePath();
	context.strokeStyle = color;
	context.stroke();
	drawCross(context, x, y, r, color, crsW);
}

// draw circle animation
function drawDynamicCirc(w, h, ctx, x, y, bckcolor, color, duration, start_r, end_r, step, callback){
	var num = Math.round(duration/step);
	var r_set = new Array(num);
	for( var i = 0; i < num; i++){
		r_set[i] = start_r+ (end_r-start_r)/num*i; // set of radius
	}
	drawCircleLoop(w, h, ctx, x, y, r_set, bckcolor, color, step, 0, callback);
}
function drawCircleLoop(w, h, ctx, x, y, r_set, bckcolor, color, step, idx, callback){
	if (RESTART) {
		DISPLAYDOTON = false;
		DISPLAYON = false;
		return;
	}
	if(idx >= r_set.length) {
		if(callback) callback();
		return;
	}
	ctx.fillStyle = bckcolor;
	ctx.fillRect(0,0,w,h);
	drawCircle(ctx, x, y, r_set[idx], color, true);
	setTimeout(function(){
		drawCircleLoop(w, h, ctx, x, y, r_set, bckcolor, color, step, idx+1, callback);
	}, step);
}


function drawDynamicRing(ctx, x, y, bckcolor, color, duration, start_r, end_r, step, callback){
	var num = Math.round(duration/step);
	var r_set = new Array(num);
	for( var i = 0; i < num; i++){
		r_set[i] = start_r+ (end_r-start_r)/num*i; // set of radius
	}
	drawRingLoop(ctx, x, y, r_set, bckcolor, color, step, 0, callback);
}

function drawRingLoop(ctx, x, y, r_set, bckcolor, color, step, idx, callback){
	if (RESTART) {
		DISPLAYDOTON = false;
		DISPLAYON = false;
		return;
	}
	if(idx >= r_set.length) {
		if(callback) callback();
		return;
	}
	drawCircle(ctx, x, y, r_set[idx], color, false);
	setTimeout(function(){
		drawRingLoop(ctx, x, y, r_set, bckcolor, color, step, idx+1, callback);
	}, step);
}

// draw a cross
function drawCross(context, x, y, r, color, width){
	context.beginPath();
	context.lineWidth = width;
	context.moveTo(x-r,y);context.lineTo(x+r,y);
	context.moveTo(x,y-r);context.lineTo(x,y+r);
	context.strokeStyle = color;
	context.stroke();
	context.closePath();
}

// draw a rounded corner rectangle
function drawRoundCornerRect(ctx, x, y, w, h, color, width){
	ctx.lineJoin = 'round';
	ctx.lineWidth = width;
	ctx.strokeStyle = color;
	rcorner = width;
	ctx.strokeRect(x, y, w+(rcorner/2), h+(rcorner/2));
	ctx.stroke();
	ctx.lineJoin = 'miter';
}

// image gallery on a fixed grid
function drawGridsImg(ctx, loc, size, imggrid){
	var numy = loc.length;
	var numx = loc[0].length;
	var w = size[1], h = size[0];

	for(var i = 0; i < numy; i++){
		for(var j = 0; j < numx; j++){
			var image;
			if(MEMTESTPREVIEW){
				image = iconset[gridimgs[i][j]];
			}else{
				image = hitimgs[gridimgs[i][j]];
			}
			var s = Math.min(w/image.width, h/image.height);
		    var rsw = image.width*s, rsh = image.height*s;
		    ctx.drawImage(image, loc[i][j][0]+(w-rsw)/2, loc[i][j][1]+(h-rsh)/2, rsw, rsh);
		}
	}
}

// get coordinates of grids
function getgridloc(x, y, size, grids, spacing){
	var numy = grids[0];
	var numx = grids[1];
	var w = size[1], h = size[0];
	var loc = new Array(numy); // one row
	for(var i = 0; i < numy; i++){
		loc[i] = new Array(numx);
		for(var j = 0; j < numx; j++){
			loc[i][j] = new Array(2);
			loc[i][j][0] = x + (j+1)*spacing + j*w;
			loc[i][j][1] = y + (i+1)*spacing + i*h;
		}
	}
	return loc;
}

// draw grids
function drawGrids(ctx, x, y, loc, size, sel, selans, color, selcolor, width, selwidth){
	var numy = loc.length;
	var numx = loc[0].length;
	var w = size[1], h = size[0];
	// draw grids
	ctx.beginPath();
	for(var i = 0; i < numy; i++){
		for(var j = 0; j < numx; j++){
			if(sel[i][j] == 0){
				drawRoundCornerRect(ctx, loc[i][j][0], loc[i][j][1], w, h, color, width);			
			}
			else if(selans[i][j] == 1){
				drawRoundCornerRect(ctx, loc[i][j][0], loc[i][j][1], w, h, selcolor[0], selwidth);
			}
			else{
				drawRoundCornerRect(ctx, loc[i][j][0], loc[i][j][1], w, h, selcolor[1], selwidth);
			}
		}
	}
}

function getNextFrame(){
	var startPos = ImageData.indexOf(';', dataPos)+1; // skip time stamp
	if (startPos == 0){
		return '';
	}
	var endPos = ImageData.indexOf(';', startPos);
	if (endPos == -1){
		return '';
	}
	dataPos = endPos+1;
	return ImageData.substring(startPos, endPos);
}

function quitfullscreen(){
	postErrMsg(save_fnmae_err, upload_url_err, 'click quit full screen;');
	if(window.innerHeight == screen.height){
		toggleFullScreen();
	}
	$('#quitFullScreenButton').hide();
	/*
	$('#closeWinButton').css( "backgroundColor", closeTabBttnColor);
	$('#closeWinButton').prop('disabled', false); // close tab;
	displayElm2Center('#closeWinButton', $(window).width(), $(window).height());
	*/
}
function closetab(){
	// postErrMsg(save_fnmae_err, upload_url_err, 'click close tab;')
	open(location, '_self').close();
	window.open('','_parent','');
	window.close();
	// var r = confirm("Please make sure you have copied and pased the completion code. You want to close the window?");
	// if (r == true) open(location, '_self').close();
}

</script>
</body>
</html>
